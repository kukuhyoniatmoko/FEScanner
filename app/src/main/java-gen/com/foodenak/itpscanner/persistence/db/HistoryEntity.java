package com.foodenak.itpscanner.persistence.db;

import com.foodenak.itpscanner.persistence.dao.DaoSession;
import com.foodenak.itpscanner.persistence.dao.HistoryEntityDao;
import com.foodenak.itpscanner.persistence.dao.UserEntityDao;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END

/**
 * Entity mapped to table "HISTORY_ENTITY".
 */
public class HistoryEntity implements java.io.Serializable {

  private Long id;
  private Long eventId;
  private java.util.Date lastRedeemDate;
  private Long userId;

  /** Used to resolve relations */
  private transient DaoSession daoSession;

  /** Used for active entity operations. */
  private transient HistoryEntityDao myDao;

  private UserEntity userEntity;
  private Long userEntity__resolvedKey;

  // KEEP FIELDS - put your custom fields here
  // KEEP FIELDS END

  public HistoryEntity() {
  }

  public HistoryEntity(Long id) {
    this.id = id;
  }

  public HistoryEntity(Long id, Long eventId, java.util.Date lastRedeemDate, Long userId) {
    this.id = id;
    this.eventId = eventId;
    this.lastRedeemDate = lastRedeemDate;
    this.userId = userId;
  }

  /** called by internal mechanisms, do not call yourself. */
  public void __setDaoSession(DaoSession daoSession) {
    this.daoSession = daoSession;
    myDao = daoSession != null ? daoSession.getHistoryEntityDao() : null;
  }

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public Long getEventId() {
    return eventId;
  }

  public void setEventId(Long eventId) {
    this.eventId = eventId;
  }

  public java.util.Date getLastRedeemDate() {
    return lastRedeemDate;
  }

  public void setLastRedeemDate(java.util.Date lastRedeemDate) {
    this.lastRedeemDate = lastRedeemDate;
  }

  public Long getUserId() {
    return userId;
  }

  public void setUserId(Long userId) {
    this.userId = userId;
  }

  /** To-one relationship, resolved on first access. */
  public UserEntity getUserEntity() {
    Long __key = this.userId;
    if (userEntity__resolvedKey == null || !userEntity__resolvedKey.equals(__key)) {
      if (daoSession == null) {
        throw new DaoException("Entity is detached from DAO context");
      }
      UserEntityDao targetDao = daoSession.getUserEntityDao();
      UserEntity userEntityNew = targetDao.load(__key);
      synchronized (this) {
        userEntity = userEntityNew;
        userEntity__resolvedKey = __key;
      }
    }
    return userEntity;
  }

  public void setUserEntity(UserEntity userEntity) {
    synchronized (this) {
      this.userEntity = userEntity;
      userId = userEntity == null ? null : userEntity.getId();
      userEntity__resolvedKey = userId;
    }
  }

  /**
   * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity
   * context.
   */
  public void delete() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.delete(this);
  }

  /**
   * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity
   * context.
   */
  public void update() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.update(this);
  }

  /**
   * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity
   * context.
   */
  public void refresh() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.refresh(this);
  }

  // KEEP METHODS - put your custom methods here
  // KEEP METHODS END
}
